# src/interpreter.py
from __future__ import annotations
from typing import Any, Dict, List, Tuple, Optional
from pathlib import Path

from .ast_builder import build_ast
from .tokenizer import tokenize
from .parser import parse
from .names import normalize_module_slug, check_capability

class RuntimeErrorLoom(Exception):
    pass
# src/interpreter.py
from __future__ import annotations
import json
from typing import Any, Dict, List, Optional, Tuple

from .ast_builder import build_ast
from .tokenizer import tokenize
from .parser import parse
from .names import normalize_module_slug, check_capability

class RuntimeErrorLoom(Exception):
    pass

# ------------------------------------------------------------
# Verb normalization: map many human verbs → small canonical set
# Canonical verbs the VM implements: Make, Show, Return, Ask, Choose, Repeat, Call
# ------------------------------------------------------------
VERB_ALIASES = {
    # assignment
    "make": "Make", "set": "Make", "let": "Make", "assign": "Make", "define": "Make",
    # show/log
    "show": "Show", "print": "Show", "log": "Show", "echo": "Show",
    # return
    "return": "Return", "yield": "Return",
    # ask
    "ask": "Ask", "prompt": "Ask", "input": "Ask",
    # choose / if
    "choose": "Choose", "if": "Choose",
    # repeat / loop
    "repeat": "Repeat", "for": "Repeat", "foreach": "Repeat", "loop": "Repeat",
    # call / invoke
    "call": "Call", "invoke": "Call", "run": "Call", "use": "Call",
}

def normalize_verb_and_args(step: Dict[str, Any]) -> Tuple[str, Dict[str, Any], Optional[str]]:
    """Return (canonicalVerb, normalizedArgs, rawVerb). May adapt arg shapes."""
    raw = (step.get("verb") or "").strip()
    canon = VERB_ALIASES.get(raw.lower(), raw)
    args = dict(step.get("args") or {})

    # Shape adapters (accept common outline shapes and normalize)
    if canon == "Make":
        # Accept multiple shapes for assignment target:
        # name/target/var/id/key/binding/lhs
        if "name" not in args:
            for k in ("target", "var", "id", "key", "binding", "lhs"):
                if k in args:
                    args["name"] = args.pop(k)
                    break
        # Accept multiple shapes for RHS expression/value:
        # expr/value/to/rhs/with/is/equals
        if "expr" not in args:
            for k in ("value", "to", "rhs", "with", "is", "equals"):
                if k in args:
                    args["expr"] = args.pop(k)
                    break
        # evaluator handles dict vs scalar for expr/value

    elif canon == "Show":
        # Accept {"text": ...} or {"value": ...} → use "expr" slot
        if "expr" not in args:
            if "text" in args:
                args["expr"] = args.get("text")
            elif "value" in args:
                args["expr"] = args.get("value")

    elif canon == "Ask":
        # Accept {"prompt": "..."} as alias for {"text": "..."}
        if "text" not in args and "prompt" in args:
            args["text"] = args.get("prompt")

    elif canon == "Choose":
        # Accept {"if": cond, "then": [...], "else": [...]}
        if "branches" not in args:
            brs: List[Dict[str, Any]] = []
            cond = args.get("if")
            if cond is not None:
                then = args.get("then") or args.get("do") or []
                els  = args.get("else") or []
                brs.append({"cond": cond, "steps": then})
                if els:
                    brs.append({"cond": {"type": "Bool", "value": True}, "steps": els})
            if brs:
                args["branches"] = brs

    elif canon == "Repeat":
        # Accept For-shape: {"var":"i","in":<iter>} or {"iterator":"i","iterable":...}
        if "iterator" not in args:
            if "var" in args:
                args["iterator"] = args.pop("var")
            elif "it" in args:
                args["iterator"] = args.pop("it")
        if "iterable" not in args:
            if "in" in args:
                args["iterable"] = args.pop("in")
            elif "range" in args:
                pass
        # Accept "body" or raw list as steps
        if "block" not in args and "steps" not in args and "body" in args:
            args["block"] = {"steps": args.pop("body")}
        if "block" not in args and "steps" in args and isinstance(args.get("steps"), list):
            args["block"] = {"steps": args.pop("steps")}

    elif canon == "Call":
        # Accept {"module": "...", "inputs": {...}}
        # Also accept {"target": "..."} as alias for module
        if "module" not in args and "target" in args:
            args["module"] = args.pop("target")

    return canon, args, raw or None


class Evaluator:
    """Tiny expression evaluator for the Loom AST node shapes."""

    def __init__(self, env: Dict[str, Any]):
        self.env = env

    def eval(self, node: Dict[str, Any]) -> Any:
        if node is None:
            return None
        typ = node.get("type")
        if typ == "Identifier":
            return self.env.get(node.get("name"))
        if typ == "String":
            return node.get("value", "")
        if typ == "Number":
            return node.get("value", 0)
        if typ == "Bool":
            return bool(node.get("value"))
        if typ == "BinaryExpr":
            op = node.get("op")
            left = self.eval(node.get("left"))
            right = self.eval(node.get("right"))
            if op == "+": return left + right
            if op == "-": return left - right
            if op == "*": return left * right
            if op == "/": return left / right
            if op in ("==", "equals"): return left == right
            if op in ("!=", "notEquals"): return left != right
            if op in ("<", "lt"): return left < right
            if op in ("<=", "lte"): return left <= right
            if op in (">", "gt"): return left > right
            if op in (">=", "gte"): return left >= right
            raise RuntimeErrorLoom(f"Unsupported binary op: {op}")
        if typ == "Call":
            # not used here; module calls handled at interpreter level
            return None
        return node


class Interpreter:
    def __init__(self):
        self.env: Dict[str, Any] = {}
        self.receipt: Dict[str, Any] = {
            "module": None,
            "moduleNorm": None,
            "inputs": {},
            "inputsResolved": {},
            "steps": [],
            "callGraph": [],
            "capabilityCheck": {"enforced": False, "status": "warn"},
            "env": {},
        }

    def _get_expr(self, args: Dict[str, Any], *keys: str) -> Optional[Dict[str, Any]]:
        for k in keys:
            v = args.get(k)
            if v is not None:
                return v
        return None

    def _extract_flow(self, module: Dict[str, Any]) -> List[Dict[str, Any]]:
        return module.get("flow") or module.get("steps") or module.get("block", {}).get("steps") or []

    def exec_step(self, step: Dict[str, Any], step_index: int = 0) -> Tuple[Any, bool]:
        canon_verb, args, raw_verb = normalize_verb_and_args(step)

        # ---- Make (assignment) ----
        if canon_verb == "Make":
            name = args.get("name")
            if not isinstance(name, str) or not name:
                raise RuntimeErrorLoom("Make: missing 'name'")
            val_node = self._get_expr(args, "expr", "value")
            value = self.evaluator.eval(val_node) if isinstance(val_node, dict) else val_node
            self.env[name] = value
            self.receipt["steps"].append({"event": "make", "name": name, "value": value, "verb": "Make", "rawVerb": raw_verb})
            return None, False

        # ---- Show (print/log) ----
        if canon_verb == "Show":
            expr = self._get_expr(args, "expr", "value", "text")
            value = self.evaluator.eval(expr) if isinstance(expr, dict) else expr
            self.receipt["steps"].append({"event": "show", "value": value, "verb": "Show", "rawVerb": raw_verb})
            print(value)
            return None, False

        # ---- Return ----
        if canon_verb == "Return":
            expr = self._get_expr(args, "expr", "value")
            value = self.evaluator.eval(expr) if isinstance(expr, dict) else expr
            self.receipt["steps"].append({"event": "return", "value": value, "verb": "Return", "rawVerb": raw_verb})
            return value, True

        # ---- Ask (no real IO; stubbed for now) ----
        if canon_verb == "Ask":
            prompt = args.get("text") or ""
            self.receipt["steps"].append({"event": "ask", "text": prompt, "verb": "Ask", "rawVerb": raw_verb})
            return None, False

        # ---- Choose (if/else) ----
        if canon_verb == "Choose":
            branches: List[Dict[str, Any]] = list(args.get("branches") or [])
            for b in branches:
                cond = b.get("cond") or {"type": "Bool", "value": True}
                ok = self.evaluator.eval(cond) if isinstance(cond, dict) else bool(cond)
                if ok:
                    res = self.exec_block({"steps": b.get("steps") or []})
                    return res, False
            return None, False

        # ---- Repeat ----
        if canon_verb == "Repeat":
            iterator = args.get("iterator")
            iterable = args.get("iterable")
            rng = args.get("range")
            block = args.get("block") or {"steps": []}

            if rng and isinstance(rng, dict) and rng.get("type") == "Range":
                start = rng.get("start", 0)
                end = rng.get("end", 0)
                step_v = rng.get("step", 1)
                it = range(int(start), int(end), int(step_v))
            elif isinstance(iterable, list):
                it = iterable
            else:
                it = []

            for item in it:
                if iterator:
                    self.env[iterator] = item
                self.exec_block(block)
            self.receipt["steps"].append({"event": "repeat", "verb": "Repeat", "rawVerb": raw_verb})
            return None, False

        # ---- Call (module call) ----
        if canon_verb == "Call":
            target_raw = args.get("module")
            target_norm = normalize_module_slug(target_raw or "")
            # capability check is recorded (warn-only unless enforced on run)
            self.receipt["callGraph"].append({"from": self.receipt.get("module"), "to": target_raw})
            self.receipt["steps"].append({"event": "call", "module": target_raw, "moduleNorm": target_norm, "verb": "Call", "rawVerb": raw_verb})
            return None, False

        raise RuntimeErrorLoom(f"Unsupported verb: {canon_verb}")

    def exec_block(self, block: Dict[str, Any]) -> Any:
        steps: List[Dict[str, Any]] = list(block.get("steps") or [])
        for idx, step in enumerate(steps):
            res, returned = self.exec_step(step, step_index=idx)
            if returned:
                return res
        return None

    def run(self, module: Dict[str, Any], inputs: Dict[str, Any] | None = None, *, enforce_capabilities: bool = False) -> Any:
        self.env = dict(inputs or {})
        self.evaluator = Evaluator(self.env)
        self.receipt.update({
            "module": module.get("name"),
            "moduleNorm": normalize_module_slug(module.get("name") or ""),
            "inputs": dict(inputs or {}),
            "inputsResolved": dict(inputs or {}),  # simple echo for now
            "capabilityCheck": {
                "enforced": bool(enforce_capabilities),
                "status": "fail" if enforce_capabilities else "warn"
            }
        })

        flow = self._extract_flow(module)
        result = self.exec_block({"steps": flow})
        # capture env at end; ensure deterministic JSON (sorted elsewhere)
        self.receipt["env"] = dict(self.env)
        return result

# ---------------- Verb normalization (aliases -> canonical) ----------------
# Canonical verbs implemented: Make, Show, Return, Ask, Choose, Repeat, Call
VERB_ALIASES = {
    # assignment
    "make": "Make", "set": "Make", "let": "Make", "assign": "Make", "define": "Make",
    # show/log
    "show": "Show", "print": "Show", "log": "Show", "echo": "Show",
    # return
    "return": "Return", "yield": "Return",
    # ask (input/prompt)
    "ask": "Ask", "prompt": "Ask", "input": "Ask",
    # choose / if
    "choose": "Choose", "if": "Choose",
    # repeat / loop
    "repeat": "Repeat", "for": "Repeat", "foreach": "Repeat", "foreach": "Repeat", "loop": "Repeat",
    # call / invoke
    "call": "Call", "invoke": "Call", "run": "Call", "use": "Call",
}

def normalize_verb_and_args(step: Dict[str, Any]) -> Tuple[str, Dict[str, Any], Optional[str]]:
    """Return (canonicalVerb, normalizedArgs, rawVerb). Also adapts common arg shapes."""
    raw = (step.get("verb") or "").strip()
    canon = VERB_ALIASES.get(raw.lower(), raw)
    args = dict(step.get("args") or {})

    if canon == "Make":
        # Accept many target-name spellings
        if "name" not in args:
            for cand in ("target", "var", "identifier", "id", "key"):
                if cand in args:
                    args["name"] = args.pop(cand)
                    break
            if "binding" in args and isinstance(args["binding"], dict):
                b = args["binding"]
                args["name"] = b.get("name") or b.get("id") or b.get("var") or args.get("name")
            if "lhs" in args and isinstance(args["lhs"], dict) and args["lhs"].get("type") == "Identifier":
                args["name"] = args["lhs"].get("name") or args.get("name")
        # Accept many value spellings
        if "expr" not in args:
            for cand in ("value", "to", "rhs", "with", "is", "equals"):
                if cand in args:
                    args["expr"] = args[cand]
                    break

    elif canon == "Show":
        if "expr" not in args:
            if "text" in args: args["expr"] = args["text"]
            elif "value" in args: args["expr"] = args["value"]

    elif canon == "Choose" and "branches" not in args:
        # If/Then/Else sugar
        cond = args.pop("cond", None)
        then_body = args.pop("then", None) or args.pop("thenBody", None)
        else_body = args.pop("else", None) or args.pop("otherwise", None)
        branches: List[Dict[str, Any]] = []
        if cond is not None:
            branches.append({"when": cond, "steps": then_body or []})
        branches.append({"steps": else_body or []})
        args["branches"] = branches

    elif canon == "Repeat":
        if "iterator" not in args:
            if "var" in args: args["iterator"] = args.pop("var")
            elif "it" in args: args["iterator"] = args.pop("it")
        if "iterable" not in args and "in" in args:
            args["iterable"] = args.pop("in")
        if "block" not in args and "steps" not in args and "body" in args:
            args["block"] = {"steps": args.pop("body")}

    elif canon == "Call":
        if "inputs" not in args and "with" in args:
            args["inputs"] = args.pop("with")
        if "result" not in args:
            for key in ("as", "saveAs", "save"):
                if key in args:
                    args["result"] = args.pop(key)
                    break

    return canon, args, (raw if raw != canon else None)

# ------------------------- expression evaluator -------------------------
class Evaluator:
    def __init__(self, env: Dict[str, Any]):
        self.env = env

    def eval(self, node: Optional[Dict[str, Any]]) -> Any:
        if node is None:
            return None
        t = node.get("type")
        if t in ("Number", "String", "Boolean"):
            return node.get("value")
        if t == "Identifier":
            name = node.get("name")
            if name in self.env:
                return self.env[name]
            raise RuntimeErrorLoom(f"Undefined identifier: {name}")
        if t == "Unary":
            op = node.get("op"); v = self.eval(node.get("expr"))
            if op == "-": return -v
            if op == "+": return +v
            if op == "not": return not bool(v)
            raise RuntimeErrorLoom(f"unknown unary op: {op}")
        if t == "Binary":
            op = node.get("op")
            if op == "and":
                l = self.eval(node.get("left"))
                if not isinstance(l, bool): raise RuntimeErrorLoom("and expects booleans")
                if not l: return False
                r = self.eval(node.get("right"))
                if not isinstance(r, bool): raise RuntimeErrorLoom("and expects booleans")
                return l and r
            if op == "or":
                l = self.eval(node.get("left"))
                if not isinstance(l, bool): raise RuntimeErrorLoom("or expects booleans")
                if l: return True
                r = self.eval(node.get("right"))
                if not isinstance(r, bool): raise RuntimeErrorLoom("or expects booleans")
                return l or r
            l = self.eval(node.get("left")); r = self.eval(node.get("right"))
            if op == "+": return l + r
            if op == "-": return l - r
            if op == "*": return l * r
            if op == "/": return l / r
            if op == "==": return l == r
            if op == "!=": return l != r
            if op == "<": return l < r
            if op == "<=": return l <= r
            if op == ">": return l > r
            if op == ">=": return l >= r
            raise RuntimeErrorLoom(f"unknown binary op: {op}")
        if t == "Range":
            start = int(self.eval(node.get("start"))); end = int(self.eval(node.get("end")))
            inclusive = bool(node.get("inclusive"))
            return list(range(start, end + 1 if inclusive else end))
        if t == "Call":
            return f"[expr-call:{node}]"
        return str(node)

# --------------------------- interpreter core ----------------------------
class Interpreter:
    def __init__(
        self,
        registry: Optional[Dict[str, Dict[str, Any]]] = None,
        capabilities: Optional[Dict[str, Any]] = None,
        enforce_capabilities: bool = False,
    ):
        self.env: Dict[str, Any] = {}
        self.evaluator = Evaluator(self.env)
        self.registry = registry or {}
        self.capabilities = capabilities
        self.enforce_capabilities = bool(enforce_capabilities)
        self.receipt: Dict[str, Any] = {
            "engine": "interpreter",
            "logs": [],
            "ask": [],
            "callGraph": [],
            "steps": [],
            "env": {},
        }
        self._call_stack: List[str] = []

    @staticmethod
    def _get_expr(args: Dict[str, Any], *keys: str) -> Optional[Dict[str, Any]]:
        for k in keys:
            if k in args:
                return args.get(k)
        return None

    def _extract_flow(self, module: Dict[str, Any]) -> List[Dict[str, Any]]:
        return module.get("flow") or module.get("steps") or module.get("block", {}).get("steps") or []

    def exec_step(self, step: Dict[str, Any], step_index: int = 0) -> Tuple[Any, bool]:
        canon_verb, args, raw_verb = normalize_verb_and_args(step)

        # ---- Make (assignment) ----
        if canon_verb == "Make":
            name = args.get("name")
            if not isinstance(name, str) or not name:
                keys_seen = ", ".join(sorted(args.keys()))
                raise RuntimeErrorLoom(
                    "Make: missing 'name' "
                    f"(saw keys: {keys_seen}; accepted: name, target, var, identifier, id, key, "
                    "binding{name}, lhs(Identifier.name))"
                )
            val_node = self._get_expr(args, "expr", "value", "to", "rhs", "with", "is", "equals")
            value = self.evaluator.eval(val_node) if isinstance(val_node, dict) else val_node
            self.env[name] = value
            self.receipt["steps"].append({"event": "make", "name": name, "value": value, "verb": "Make", "rawVerb": raw_verb})
            return None, False

        # ---- Show (print/log) ----
        if canon_verb == "Show":
            expr = self._get_expr(args, "expr", "text", "value")
            val = self.evaluator.eval(expr) if isinstance(expr, dict) else (expr if expr is not None else "")
            self.receipt["logs"].append(str(val))
            self.receipt["steps"].append({"event": "show", "value": str(val), "verb": "Show", "rawVerb": raw_verb})
            print(val)
            return None, False

        # ---- Return ----
        if canon_verb == "Return":
            expr = self._get_expr(args, "expr", "value")
            val = self.evaluator.eval(expr) if isinstance(expr, dict) else expr
            self.receipt["steps"].append({"event": "return", "value": val, "verb": "Return", "rawVerb": raw_verb})
            return val, True

        # ---- Ask ----
        if canon_verb == "Ask":
            name = args.get("name")
            default_expr = args.get("default")
            if name not in self.env:
                self.env[name] = self.evaluator.eval(default_expr) if default_expr is not None else None
            self.receipt["ask"].append({"verb": "Ask", "name": name, "default": default_expr})
            self.receipt["steps"].append({"event": "ask", "name": name, "verb": "Ask", "rawVerb": raw_verb})
            return None, False

        # ---- Choose (when/otherwise) ----
        if canon_verb == "Choose":
            branches = args.get("branches") or []
            for idx, br in enumerate(branches):
                pred = br.get("when")
                if pred is not None:
                    val = bool(self.evaluator.eval(pred))
                    self.receipt["steps"].append({"event": "choose", "predicateTrace": [{"expr": pred, "value": val}], "selected": {"branch": idx, "kind": "when"} if val else None, "verb": "Choose", "rawVerb": raw_verb})
                    if val:
                        body = br.get("steps") or br.get("block") or br.get("body") or []
                        if isinstance(body, dict): body = body.get("steps") or []
                        for st in body:
                            res, returned = self.exec_step(st)
                            if returned: return res, True
                        return None, False
                else:
                    body = br.get("steps") or br.get("block") or br.get("body") or []
                    if isinstance(body, dict): body = body.get("steps") or []
                    for st in body:
                        res, returned = self.exec_step(st)
                        if returned:
                            self.receipt["steps"].append({"event": "choose", "predicateTrace": [], "selected": {"branch": idx, "kind": "otherwise"}, "verb": "Choose", "rawVerb": raw_verb})
                            return res, True
                    self.receipt["steps"].append({"event": "choose", "predicateTrace": [], "selected": {"branch": idx, "kind": "otherwise"}, "verb": "Choose", "rawVerb": raw_verb})
                    return None, False
            return None, False

        # ---- Repeat (for) ----
        if canon_verb == "Repeat":
            iterator = args.get("iterator"); it_name = None
            if isinstance(iterator, dict) and "name" in iterator: it_name = iterator["name"]
            elif isinstance(iterator, str): it_name = iterator
            if not it_name: it_name = args.get("iter")

            iterable_expr = args.get("iterable"); 
            if iterable_expr is None: iterable_expr = args.get("range")
            if iterable_expr is None or not it_name:
                raise RuntimeErrorLoom("Malformed Repeat: missing iterator/iterable")

            if isinstance(iterable_expr, dict) and iterable_expr.get("type") == "Range":
                start = int(self.evaluator.eval(iterable_expr.get("start")))
                end = int(self.evaluator.eval(iterable_expr.get("end")))
                inclusive = bool(iterable_expr.get("inclusive"))
                values = list(range(start, end + 1 if inclusive else end))
            else:
                values = list(self.evaluator.eval(iterable_expr))

            blk = args.get("block") or args.get("steps") or args.get("body")
            if isinstance(blk, list): body_steps = blk
            elif isinstance(blk, dict): body_steps = blk.get("steps") or []
            else: body_steps = []

            for v in values:
                self.env[it_name] = v
                for st in body_steps:
                    res, returned = self.exec_step(st)
                    if returned: return res, True
            self.receipt["steps"].append({"event": "repeat", "iterator": it_name, "verb": "Repeat", "rawVerb": raw_verb})
            return None, False

        # ---- Call (cross-module) ----
        if canon_verb == "Call":
            raw_mod_name = args.get("module")
            inputs_obj = args.get("inputs") or {}
            child_inputs: Dict[str, Any] = {k: self.evaluator.eval(ex) for k, ex in inputs_obj.items()}

            # Resolve callee from registry or Modules/<raw>.loom
            callee = None
            if raw_mod_name in self.registry:
                callee = self.registry[raw_mod_name]
            else:
                norm_key = normalize_module_slug(raw_mod_name or "")
                callee = self.registry.get(norm_key)
            if callee is None:
                mod_file = Path("Modules") / f"{raw_mod_name}.loom"
                if not mod_file.exists():
                    raise RuntimeErrorLoom(f"Call: cannot resolve module {raw_mod_name}")
                text = mod_file.read_text(encoding="utf-8")
                callee = build_ast(parse(tokenize(text)))

            # Child interpreter shares registry/policy
            child = Interpreter(registry=self.registry, capabilities=self.capabilities, enforce_capabilities=self.enforce_capabilities)
            child.env.update(dict(self.env))
            child.env.update(child_inputs)

            # Execute child
            self._call_stack.append(callee.get("name") or raw_mod_name or "<anonymous>")
            try:
                child_result = child.exec_block({"steps": callee.get("flow") or []})
            finally:
                self._call_stack.pop()

            # inputsResolved
            inputsResolved: Dict[str, Any] = {}
            asked = [a.get("name") for a in child.receipt.get("ask", []) if isinstance(a, dict)]
            for key in set(asked) | set(child_inputs.keys()):
                if key in child_inputs:
                    inputsResolved[key] = {"source": "explicit", "value": child_inputs[key]}
                else:
                    inputsResolved[key] = {"source": "default", "value": child.env.get(key)}

            # Cap check
            caller_raw = self._call_stack[-1] if self._call_stack else "<anonymous>"
            cap = check_capability(self.capabilities, caller_raw, raw_mod_name or "", action="Call")
            violation = (cap.get("mode") != "none" and not cap.get("allowed"))
            cap_record = dict(cap)
            cap_record["mode"] = ("enforce" if self.enforce_capabilities else "warn") if cap.get("mode") != "none" else "none"

            # Record
            self.receipt["steps"].append({
                "event": "call",
                "module": raw_mod_name,
                "moduleNorm": normalize_module_slug(raw_mod_name or ""),
                "inputs": dict(child_inputs),
                "inputsResolved": inputsResolved,
                "capabilityCheck": cap_record,
                "verb": "Call",
                "rawVerb": raw_verb,
            })
            self.receipt["callGraph"].append({
                "from": caller_raw,
                "to": raw_mod_name,
                "fromNorm": normalize_module_slug(caller_raw or ""),
                "toNorm": normalize_module_slug(raw_mod_name or ""),
                "atStep": step_index
            })

            if violation and self.enforce_capabilities:
                raise RuntimeErrorLoom(f"Capability denied: Call from '{caller_raw}' to '{raw_mod_name}'")

            save_as = args.get("result") or args.get("saveAs") or args.get("save") or args.get("as")
            if save_as:
                self.env[save_as] = child_result
            return None, False

        # ---- Fallback ----
        raise RuntimeErrorLoom(f"Unknown verb: {canon_verb}")

    def exec_block(self, block: Dict[str, Any]) -> Any:
        result = None
        for idx, step in enumerate(block.get("steps", [])):
            res, returned = self.exec_step(step, step_index=idx)
            if returned:
                result = res
                break
        return result

    def run(self, module: Dict[str, Any], inputs: Optional[Dict[str, Any]] = None) -> Any:
        if inputs:
            self.env.update(inputs)
        name = module.get("name") or module.get("module", {}).get("name") or "<anonymous>"
        self._call_stack.append(name)
        try:
            flow = self._extract_flow(module)
            result = self.exec_block({"steps": flow})
            return result
        finally:
            self._call_stack.pop()
            self.receipt["env"] = dict(self.env)

# Convenience
def _load_or_build_module(path: str) -> Dict[str, Any]:
    p = Path(path)
    text = p.read_text(encoding="utf-8")
    return build_ast(parse(tokenize(text)))

def run_module_from_file(path: str, inputs: Optional[Dict[str, Any]] = None) -> Tuple[Any, Dict[str, Any]]:
    module = _load_or_build_module(path)
    interp = Interpreter()
    result = interp.run(module, inputs=inputs or {})
    return result, interp.receipt

def run_tests_from_file(path: str) -> Tuple[int, int, List[Any]]:
    module = _load_or_build_module(path)
    tests = module.get("tests") or []
    passed, results = 0, []
    from .expr import parse_expr
    def coerce_scalar(v: Any) -> Any:
        if isinstance(v, (int, float, bool)): return v
        if isinstance(v, str):
            s = v.strip().rstrip(".")
            try:
                node = parse_expr(s)
                return Evaluator({}).eval(node)
            except Exception:
                if s.startswith('"') and s.endswith('"'): return s[1:-1]
                return s
        return v
    def coerce_inputs(d: Dict[str, Any]) -> Dict[str, Any]:
        return {k: coerce_scalar(v) for k, v in (d or {}).items()}
    for t in tests:
        name = t.get("name") or "test"
        expected = coerce_scalar(t.get("expected"))
        inputs = coerce_inputs(t.get("inputs") or t.get("input") or {})
        actual = Interpreter().run(module, inputs=inputs)
        ok = (actual == expected)
        if ok: passed += 1
        results.append((name, ok, actual, expected))
    return passed, len(tests), results
